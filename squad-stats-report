#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# vim: set ts=4
#
# Copyright 2022-present Linaro Limited
#
# SPDX-License-Identifier: MIT


import argparse
import difflib
import json
import logging
import os
import re
import sys
import subprocess as sp
from multiprocessing import Pool
from squad_client.core.api import SquadApi
from squad_client.core.models import Squad, ALL, Test
from squad_client.shortcuts import download_tests as download
from squad_client.shortcuts import get_build
from squad_client.utils import getid

squad_host_url = "https://qa-reports.linaro.org/"
SquadApi.configure(cache=3600, url=os.getenv("SQUAD_HOST",squad_host_url))

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

KNOWN_ARCHITECTURES = [
        "arc",
        "arm",
        "arm64",
        "i386",
        "mips",
        "parisc",
        "powerpc",
        "riscv",
        "s390",
        "sh",
        "sparc",
        "x86_64",
]

KNOWN_DEVICES = [
        "bcm2711-rpi-4-b",
        "dragonboard-410c",
        "dragonboard-820c",
        "dragonboard-845c",
        "fvp-aemva",
        "hi6220-hikey",
        "i386",
        "juno-r2",
        "nxp-ls2088",
        "qemu_arm",
        "qemu_arm64",
        "qemu_i386",
        "qemu_x86_64",
        "qemu-arm64",
        "qemu-arm64be",
        "qemu-armv5",
        "qemu-armv7",
        "qemu-armv7be",
        "qemu-i386",
        "qemu-mips32",
        "qemu-mips32el",
        "qemu-mips64",
        "qemu-mips64el",
        "qemu-ppc32",
        "qemu-ppc64",
        "qemu-ppc64le",
        "qemu-riscv32",
        "qemu-riscv64",
        "qemu-s390",
        "qemu-sh4",
        "qemu-sparc64",
        "qemu-x86_64",
        "x15",
        "x86",
        ]

def parse_args():
    parser = argparse.ArgumentParser(description="Compare builds within SQUAD")

    parser.add_argument(
            "--group",
            required=True,
            help="squad group",
            )

    parser.add_argument(
            "--project",
            required=True,
            help="squad project",
            )

    parser.add_argument(
            "--from-datetime",
            required=True,
            help="Starting date time. Example: 2022-01-01 or 2022-01-01T00:00:00",
            )

    parser.add_argument(
            "--to-datetime",
            required=True,
            help="Ending date time. Example: 2022-12-31 or 2022-12-31T00:00:00",
            )

    parser.add_argument(
            "--filename", help="Name of the output file where results will be written"
            )

    parser.add_argument(
            "--debug",
            action="store_true",
            default=False,
            help="Display debug messages",
            )

    return parser.parse_args()


def get_number_of_kernel_builts(project, builds):
    suite = project.suite("build")
    envs = project.environments(count=ALL)
    archs = set()
    total = 0
    for build in builds:
        logger.debug(f"Fetching build test from {build.version}", flush=True)
        tests = build.tests(suite=suite.id, fields="id,environment").values()
        total += len(tests)

        for test in tests:
            for known_arches in KNOWN_ARCHITECTURES:
                env = envs[getid(test.environment)].slug
                if known_arches in env:
                    archs.add(env)
            #archs.add(envs[getid(test.environment)].slug)

    return total, archs


def get_devices(environments, archs):
    devices = set(environments)

    logger.debug(f"All environments {devices}")
    actual_devices = set()
    for device in devices:
        for known_device in KNOWN_DEVICES:
            if known_device in device:
                actual_devices.add(known_device)

    return actual_devices


def get_total_number_of_tests(builds):
    total = 0
    for build in builds:
        total += build.status.tests_total

    return total


def run():
    args = parse_args()
    if args.debug:
        logger.setLevel(level=logging.DEBUG)

    from_datetime = args.from_datetime
    if "T" not in from_datetime:
        from_datetime = f"{from_datetime}T00:00:00"

    to_datetime = args.to_datetime
    if "T" not in to_datetime:
        to_datetime = f"{to_datetime}T23:59:59"

    group = Squad().group(args.group)
    project = group.project(args.project)
    environments = project.environments(count=ALL).values()

    filename = args.filename or f'stats-{args.group}-{args.project}-{re.sub(r":", "_", re.sub(r"-", "",from_datetime))}-{re.sub(r":", "_", re.sub(r"-", "",to_datetime))}.txt'

    if os.path.isfile(filename):
        print(f"Report is already generated: {filename}")
        sys.exit(0)

    builds = project.builds(created_at__lt=to_datetime, created_at__gt=from_datetime, count=ALL).values()
    number_of_kernel_builts, archs = get_number_of_kernel_builts(project, builds)
    devices = get_devices([e.slug for e in environments], archs)
    total_tests = get_total_number_of_tests(builds)

    archs_str = "\n           ".join(sorted(archs))
    devices_str = "\n           ".join(sorted(devices))
    report = f"""
        project:       {project.slug}
        from:          {from_datetime}
        to:            {to_datetime}
        kernel pushes: {len(builds)}
        kernel builts: {number_of_kernel_builts}
        total tests:   {total_tests}
        architectures:
           {archs_str}
        devices:
           {devices_str}"""
    print(report)

    with open(filename, 'w') as fp:
        fp.write(report)
    print(f"file created: {filename}")

if __name__ == "__main__":
    sys.exit(run())
